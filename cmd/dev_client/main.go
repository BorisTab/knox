package main

import (
	"crypto/tls"
	"encoding/json"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"os"
	"os/user"
	"time"

	"github.com/pavelzhurov/knox"
	"github.com/pavelzhurov/knox/client"
)


// tokenEndpoint and clientID are used by "knox login" if your oauth client supports password flows.
const tokenEndpoint = "https://keycloak-dev.sup.sbc.platform5.club/auth/realms/bootcamp/protocol/openid-connect/token"
const clientID = "bootcamp-app"

// keyFolder is the directory where keys are cached
const keyFolder = "/var/lib/knox/v0/keys/"

// authTokenResp is the format of the OAuth response generated by "knox login"
type authTokenResp struct {
	AccessToken string `json:"access_token"`
	Error       string `json:"error"`
}

// authHandler is used to generate an authentication header.
// The server expects VersionByte + TypeByte + IDToPassToAuthHandler.
func authHandler() string {
	_, ok := os.LookupEnv("SPIFFE_CLIENT")
	if ok {
		return "0s"
	}
	u, err := user.Current()
	if err != nil {
		return ""
	}

	d, err := ioutil.ReadFile(u.HomeDir + "/.knox_user_auth")
	if err != nil {
		return ""
	}
	var authResp authTokenResp
	err = json.Unmarshal(d, &authResp)
	if err != nil {
		return ""
	}

	return "0u" + authResp.AccessToken
}

func main() {
	// hostname is the host running the knox server
	hostname, ok := os.LookupEnv("KNOX_SERVER")
	if !ok {
		hostname = "localhost:9000"
	}

	rand.Seed(time.Now().UTC().UnixNano())

	tlsConfig := &tls.Config{
		ServerName:         hostname,
		// InsecureSkipVerify: true,
	}
	_, ok = os.LookupEnv("SPIFFE_CLIENT")
	if ok {
		certs, err := LoadCertificates([]string{"/certs/*.key", "/certs/*.pem"})
		if err == nil {
			tlsConfig.Certificates = certs
		}
	} else {
		cert, err := getCert()
		if err == nil {
			tlsConfig.Certificates = []tls.Certificate{cert}
		}
	}

	cli := &knox.HTTPClient{
		Host:        hostname,
		AuthHandler: authHandler,
		KeyFolder:   keyFolder,
		Client:      &http.Client{Transport: &http.Transport{TLSClientConfig: tlsConfig}},
	}

	loginCommand := client.NewLoginCommand(tokenEndpoint, clientID, "", "", "", "")

	client.Run(
		cli,
		&client.VisibilityParams{
			Logf:    log.Printf,
			Errorf:  log.Printf,
			Metrics: func(map[string]uint64) {}},
		loginCommand,
	)
}
